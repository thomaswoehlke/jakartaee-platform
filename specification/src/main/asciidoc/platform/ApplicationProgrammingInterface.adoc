[[a2133]]
== Application Programming Interface

This chapter describes API requirements
for the Jakarta™ Platform, Enterprise Edition (Jakarta EE). Jakarta EE requires
the provision of a number of APIs for use by Jakarta EE applications,
starting with the core Java APIs and including many additional Java
technologies.


[[a2136]]
=== Required APIs

Jakarta EE application components execute in
runtime environments provided by the containers that are a part of the
Jakarta EE platform. The full Jakarta EE platform supports three types of
containers corresponding to Jakarta EE application component types:
application client containers; web containers for
servlets, Jakarta Server Pages, Jakarta Server Faces applications,
Jakarta RESTful Web Services applications;
and enterprise bean containers. A Jakarta EE profile may support only a subset
of these component types, as defined by the individual Jakarta EE profile
specification.

The per-technology requirements in this
chapter apply to any Jakarta EE product that includes the technology. Note
that even though a Jakarta EE profile might not require support for a
particular technology, a Jakarta EE product based on that Jakarta EE profile
might nonetheless include support for the technology. In such a case,
the requirements for that technology described in this chapter would
apply.

[[a3537]]
==== Java Compatible APIs

The containers provide all application
components with at least the Java Platform, Standard Edition, v11 (Java
SE) APIs. Containers may provide newer versions of the Java SE platform,
provided they meet all the Jakarta EE platform requirements as outlined below.

===== Java SE Enterprise Technologies

The Java SE 11 platform includes a number of enterprise technologies. Except
for technologies noted in this specification as being optional, containers
must provide all application components with the APIs associated with these
technologies. If a newer version of the Java SE platform provided by
a container has removed some of these technologies, the container must
provide these technologies in some other manner.

The Java SE 11 platform includes the following enterprise technologies:

* Java IDL footnote:[Removed from Java SE 11. Support for Java IDL is optional (see <<a3539, Java IDL (Optional)>>.) Product vendors that wish to support Java IDL on a Java SE version that does not provide the Java IDL APIs must otherwise provide those APIs to application components. ]
* JDBC
* RMI-JRMP
* javax.rmi.PortableRemoteObject footnote:[Removed from Java SE 11. Product vendors that support the optional Enterprise Beans 2.x API group must ensure that the javax.rmi.PortableRemoteObject class is available to application components.]
* JNDI
* JAXP
* StAX
* JAAS
* JMX
* JAX-WS footnote:javaremovalopt[Removed from Java SE 11. Since Jakarta EE 9 this optional technology is provided under a Jakarta EE specification. If the technology is provided, the container must provide the Jakarta EE version of the technology. See <<a2161, Required Jakarta Technologies>>.]
* JAXB footnote:javaremovalopt[]
* JAF footnote:javaremovalreq[Removed from Java SE 11. Since Jakarta EE 9 this technology is provided under a Jakarta EE specification. The container must provide the Jakarta EE version of the technology. See <<a2161, Required Jakarta Technologies>>.]
* SAAJ footnote:javaremovalopt[]
* Common Annotations footnote:javaremovalreq[]

Note that a number of the enterprise technologies provided
by Java SE 8 are now provided by Jakarta EE specifications and are
included in the list of <<a2161, Required Jakarta Technologies>>.

The specifications for the Java SE APIs are
available at _http://docs.oracle.com/javase/11/docs/_ .

===== Java Module Names
Java(TM) SE 9 introduced the concept of a modularity system, known as the Java Platform Module System (JPMS).
Defined modules need a _name_ to allow for references by other modules.
Jakarta EE 10 does not define a module naming convention.
However, some Java EE(TM) 8 and Jakarta EE features had already defined their corresponding module names.
Due to these previous module naming efforts, the following guidelines are strongly suggested for Jakarta EE 9:

* If an Automatic Module Name (MANIFEST) already exists, update the name to use the ‘jakarta’ prefix to be consistent with the package rename requirement.
Do not create _new_ Automatic Module Names for Jakarta EE 9.  
* If a module-info.class already exists, update the name to use the ‘jakarta’ prefix to be consistent with the package rename requirement.
Do not create _new_ module-info.class files for Jakarta EE 9. 
* If neither Automatic Module Names or module-info.class exists, then leave as-is.

These guidelines allow existing module names to get to a consistent state with the least amount of disruption.
Any existing module names may need to be updated once specific module name requirements are established in a future release.

[[a2161]]
==== Required Jakarta Technologies

The full Jakarta EE platform also provides a
number of technologies in each of the containers defined by this
specification. <<a2159, Jakarta EE Technologies>> indicates the technologies with their required
versions, which containers include the technologies, and whether the
technology is required (REQ), proposed optional (POPT), or optional
(OPT). Each Jakarta EE profile specification will include a similar table
describing which technologies are required for the profile. Note that
some technologies are marked Optional, as described in the next section.
Please see the table in the section Application Programming Interface for the specific versions required for each component.

*Note:* Jakarta EE 9 introduced the concept of "removed" technologies.
This is the final stage of a technology's lifecycle where the technology is
officially removed from the Jakarta EE Platform.
This is a stronger statement than making a technology "optional", since a "removed"
technology will no longer be maintained for future versions of the Platform.
<<a2333, Removed Jakarta Technologies>> documents these removed technologies.

[[a2159]]
[cols=5, options=header]
.Jakarta EE Technologies
|===
|Jakarta EE Technology
|App Client
|Web
|Enterprise Beans
|Status

|Activation
|Y
|Y
|Y
|REQ

|Authorization
|N
|Y
|Y
|REQ

|Authentication
|N
|Y
|Y
|REQ

|Batch
|N
|Y
|Y
|REQ

|Bean Validation
|Y
|Y
|Y
|REQ

|Common Annotations
|Y
|Y
|Y
|REQ

|Concurrency
|N
|Y
|Y
|REQ

|Connectors
|N
|Y
|Y
|REQ

|Contexts and Dependency Injection
|Y
|Y
|Y
|REQ

|Dependency Injection
|Y
|Y
|Y
|REQ

|Debugging Support for Other Languages
|N
|Y
|N
|REQ

|Enterprise Beans
|Y footnote:[Client APIs only.]
|Y
|Y
|REQ, OPT footnote:[Jakarta™ Enterprise Beans entity beans and associated query
language. Jakarta Enterprise Beans 2.x API group.]

|Enterprise Web Services
|Y
|Y
|Y
|OPT

|Expression Language
|N
|Y
|N
|REQ

|Interceptors
|Y
|Y
|Y
|REQ

|JSON Processing
|Y
|Y
|Y
|REQ

|JSON Binding
|Y
|Y
|Y
|REQ

|Mail
|Y
|Y
|Y
|REQ

|Managed Beans (Deprecated)
|Y
|Y
|Y
|REQ

|Messaging
|Y
|Y
|Y
|REQ

|Persistence
|Y
|Y
|Y
|REQ


|RESTful Web Services
|N
|Y
|N
|REQ

|Security
|N
|Y
|Y
|REQ

|Servlet
|N
|Y
|N
|REQ

|Server Faces
|N
|Y
|N
|REQ

|Server Pages
|N
|Y
|N
|REQ

|SOAP with Attachments
|Y
|Y
|Y
|OPT

|Standard Tag Library
|N
|Y
|N
|REQ

|Transactions
|N
|Y
|Y
|REQ

|Web Services Metadata (Moved to Enterprise Web Services)
|-
|-
|-
|OPT

|WebSocket
|N
|Y
|N
|REQ

|XML Binding
|Y
|Y
|Y
|OPT

|XML Web Services
|Y
|Y
|Y
|OPT

|===

All classes and interfaces required by
the specifications for the APIs must be provided by the Jakarta EE
containers indicated above. In some cases, a Jakarta EE product is not
required to provide objects that implement interfaces intended to be
implemented by an application server, nevertheless, the definitions of
such interfaces must be included in the Jakarta EE platform. If an
implementation includes support for a technology marked as Optional,
that technology must be supported in the containers specified above. If
a product implementation does not support a technology marked as
Optional, it must not include the APIs for that
technology.footnote:[Note that a component specification is permitted to specify
an exception to this in order to accommodate interface type dependencies—for example,
the Jakarta™ Enterprise Beans SessionContext dependency on the
_jakarta.xml.rpc.handler.MessageContext_ type.]

If a container supports Java SE 11 or a newer version of the Java SE platform, than all classes and interfaces provided by the container to satisfy the platform requirements listed above, must be compiled with the Java SE 11 source and class level.

[[a2331]]
==== Optional Jakarta Technologies

As the Jakarta EE specification has evolved,
some of the technologies originally included in Jakarta EE are no longer as
relevant as they were when they were introduced to the platform. The
Jakarta EE Platform Specification Project follows a process similar to the one first defined by the Java SE
expert group ( _http://mreinhold.org/blog/removing-features_ ) to stabilize and remove
technologies from the platform in a careful and orderly way that
minimizes the impact to developers using these technologies, while
allowing the platform to grow even stronger. In short, our process
defines three steps:

. The Platform Specification Project for release N 
of the platform decides to propose that a particular feature be
marked "proposed optional". The specification for that release documents the proposal.
. The Platform Specification Project for release N+1 decides whether to
mark the feature as "optional" for this N+1 release, retain it as a required component,
or leave it in the "proposed optional" state for the next N+2 release cycle to decide.
. Eventually, the Platform Specification Project for release N+2 (or beyond) can decide
to officially "remove" the "optional" feature from the Platform.

The result of successfully applying this
policy to a feature is to allow a gradual removal
of the feature as a required component of the platform.
Product vendors can _choose_ to remove or include an "optional" feature in their
products.
Although a "removed" feature can still be included in a vendor's product, vendors 
need to realize that the "removed" feature is no longer defined as part of the Platform
and, thus, the integration of this "removed" feature with the rest of the Platform
is left as an exercise for the vendor.

Technologies that are "proposed optional" are marked Proposed Optional (POPT) in
<<a2159, Jakarta EE Technologies>>.
Technologies that are "optional" as of Jakarta EE 9 are marked Optional (OPT) in
<<a2159, Jakarta EE Technologies>>.
Technologies that are "removed" from the Jakarta EE Platform are documented in 
<<a2333, Removed Jakarta Technologies>>.

*Note:* In order to get on a level playing field, Jakarta EE 9 took a couple of liberties
with the application of "proposed optional", "optional", and "removed" technologies per
the Jakarta EE 9 Release Plan, available at _https://eclipse-ee4j.github.io/jakartaee-platform/jakartaee9/JakartaEE9ReleasePlan_.  
Going forward, it is the expectation that Jakarta EE
releases will follow these defined policies.

[[a2333]]
==== Removed Jakarta Technologies
Jakarta EE 9 introduced the concept of "removed" technologies.
This is the final stage of a technology's lifecycle where the technology is
officially *removed* from the Jakarta EE Platform.
This is a stronger statement than making a technology "optional", since a "removed"
technology will no longer be maintained for future versions of the Platform.

The following Jakarta EE Technologies were removed from the Jakarta EE Platform.
[[a2160]]
[cols=2, options=header]
.Jakarta EE Technologies
|===
|Jakarta EE Technology
|Status

|Entity Beans, both Container and Bean Managed Persistence (Jakarta Enterprise Beans 4.0, Optional Features, Chapters 3 - 7)
|Removed in Jakarta EE 10

|Embeddable EJB Container (Jakarta Enterprise Beans, Core Features 4.0, Chapter 17)
|Removed in Jakarta EE 10
|===

[[a2339]]
=== Java Platform, Standard Edition (Java SE) Requirements

==== Programming Restrictions

The Jakarta EE programming model divides
responsibilities between Application Component Providers and Jakarta EE
Product Providers: Application Component Providers focus on writing
business logic and the Jakarta EE Product Providers focus on providing a
managed system infrastructure in which the application components can be
deployed.

This division leads to a restriction on the
functionality that application components can contain. If application
components contain the same functionality provided by Jakarta EE system
infrastructure, there are clashes and mis-management of the
functionality.

For example, if enterprise beans were
allowed to manage threads, the Jakarta EE platform could not manage the
life cycle of the enterprise beans, and it could not properly manage
transactions.

Since we do not want to subset the Java SE
platform, and we want Jakarta EE Product Providers to be able to use Java
SE products without modification in the Jakarta EE platform, we use the
Java SE security permissions mechanism to express the programming
restrictions imposed on Application Component Providers.

In this section, we specify the Java SE
security permissions that the Jakarta EE Product Provider must provide for
each application component type. We call these permissions the Jakarta EE
security permissions set. The Jakarta EE security permissions set is a
required part of the Jakarta EE API contract. We also specify the set of
permissions that the Jakarta EE Product Provider must be able to restrict
from being provided to application components. In addition, we specify
the means by which application component providers may declare the need
for specific permissions and how these declarations must be processed by
Jakarta EE products.

The Java SE security permissions are fully
described in
_http://docs.oracle.com/javase/8/docs/technotes/guides/security/permissions.html_
.

==== Jakarta EE Security Manager Related Requirements

Every Jakarta EE product must be capable of
running with a Java security manager that enforces Java security
permissions and that prevents application components from performing
operations for which they have not been provided the required
permissions.

===== Jakarta EE Product Provider’s Responsibilities

A Jakarta EE product may allow application
components to run without a security manager, but every Jakarta EE product
must be capable of running application components with a security
manager that enforces security permissions, as described below.

The set of security permissions provided to
application components by a particular installation is a matter of
policy outside the scope of this specification, however, every Jakarta EE
product must be capable of running with a configuration that provides
application classes and packaged libraries the permissions defined in
<<a2366, Jakarta EE Security Permissions Set>>.

All Jakarta EE products must allow the set of
permissions available to application classes in a module to be
configurable, providing application components in some modules with
different permissions than those described in
<<a2366, Jakarta EE Security Permissions Set>>.

As defined in
<<a2496, Declaring Permissions Required by Application Components>>, a component provider may declare
the permissions required by the application classes and libraries
packaged in a module. When a component provider has declared the
permissions required by a module, on successful deployment of the
module, at least the declared permissions must have been granted to the
application classes and libraries packaged in the module. If security
permissions are declared that conflict with the policy of the product
installation, the Jakarta EE product must fail deployment of the
application module. If an application module does not contain a
declaration of required security permissions and deployment otherwise
succeeds, the Jakarta EE product must grant the application classes and
libraries the permissions established by the security policy of the
installation. The Jakarta EE product must ensure that the system
administrator for the installation be able to define the security policy
for the installation to include the permissions in
<<a2366, Jakarta EE Security Permissions Set>>.

Note that, on some installations of Jakarta EE
products, the security policy of the installation may be such that
applications are granted fewer permissions than those defined in
<<a2366, Jakarta EE Security Permissions Set>> and, as a result, some applications that declare only
the permissions defined in
<<a2366, Jakarta EE Security Permissions Set>> may not be deployable. Other applications that require
the same permissions but do not declare them may deploy but will
encounter runtime failures when the missing permission is required by
the application component.

Every Jakarta EE product must be capable of
running with a Java security manager and with an installation policy
that does not grant the permissions described in
<<a2438, Restrictable Jakarta EE Security Permissions>> to Web, enterprise beans, and resource adapter components. That
environment must otherwise fully support the requirements of this
specification.

===== Application Component Provider’s Responsibilities

To ensure that application deployment will
only succeed if required permissions are compatible with security policy
of the installation environment, application component providers should
declare all Java security permissions required by their application
components.

<<a2496, Declaring Permissions Required by Application Components>>, defines the
mechanism(s) by which required permissions may be declared.

Note that, while FilePermissions or
SocketPermissions for specific resources may be granted as a result of
application components declaring them as required, the local operating
system or network security policy may restrict access to the requested
resources. This may result in a runtime failure to access these
resources even though deployment of the application has succeeded.

===== System Administrator’s Responsibilities

Security policy requirements differ from one
installation environment to another. The system administrator is
responsible for configuring the permissions available to application
modules to meet the security policy requirements of the installation
environment. For example, cloud environments may require greater
restrictions on the system resources available to applications than
on-premise enterprise installations. Note that restricting the
permissions beyond those in
<<a2366, Jakarta EE Security Permissions Set>> may prevent some applications from working correctly.

Care should be taken by the system
administrator to ensure that resources that are expected to be available
to application components are appropriately represented in the security
policy of the operational environment.

In particular, the temporary file directory
made available through the ServletContext attribute
_jakarta.servlet.context.tempdir_ should be available to deployed
applications. The security policy of the operational environment should
grant the application server process access to the corresponding part of
the file system. The Jakarta EE Product must be capable of using the
security manager to enforce that an application only has access to the
part of the filesystem namespace named by the
_javax.security.context.tempdir_ attribute, and that that part of the
filesystem namespace is separate from the corresponding filesystem
namespace available to other applications.

===== Listing of the Jakarta EE Security Permissions Set

<<a2366, Jakarta EE Security Permissions Set>> lists the Java permissions that Jakarta
EE components (by type) can reliably be granted by a Jakarta EE product,
given appropriate local installation configuration.

[[a2366]]
[cols=3, options=header]
.Jakarta EE Security Permissions Set
|===
|Security Permissions
|Target
|Action

|Application Clients
|
|

|java.awt.AWTPermission
|accessClipboard
|

|java.awt.AWTPermission
|accessEventQueue
|

|java.awt.AWTPermission
|showWindowWithout
WarningBanner
|

|java.lang.RuntimePermission
|exitVM
|

|java.lang.RuntimePermission
|loadLibrary.*
|

|java.lang.RuntimePermission
|queuePrintJob
|

|java.net.SocketPermission
|*
|connect

|java.net.SocketPermission
|localhost:1024-
|accept,listen

|java.io.FilePermission
|*
|read,write

|java.util.PropertyPermission
|*
|read

|Applet Clients
|
|

|java.net.SocketPermission
|codebase
|connect

|java.util.PropertyPermission
|limited
|read

|Web, Enterprise Beans, and Resource Adapter
Components
|
|

|java.lang.RuntimePermission
|loadLibrary.*
|

|java.lang.RuntimePermission
|queuePrintJob
|

|java.net.SocketPermission
|*
|connect

|java.io.FilePermission
|*
|read,write footnote:[The FilePermission * specifically refers to all files
under the current directory.]

|java.io.FilePermission
|file:${jakarta.servlet.context.tempdir}
|read, write footnote:[(For Web components only.) It must be possible to grant
FilePermission for the tempdir provided to web components through the ServletContext
regardless of its physical location. In addition, it must be possible to grant
FilePermission for the tempdir without granting it for all files under
the current directory.]

|java.util.PropertyPermission
|*
|read
|===

===== Restrictable Jakarta EE Security Permissions

<<a2438, Restrictable Jakarta EE Security Permissions>> lists the Java permissions
that a Jakarta EE product must be capable of restricting when running a Web
or Enterprise Beans application component. If the Target field is empty, a Jakarta EE
product must be capable of deploying application modules such that no
instances of that permission are granted to the components in the
application module.


[[a2438]]
[cols=3, options=header]
.Restrictable Jakarta EE Security Permissions
|===
|Security Permissions
|Target
|Action

|Web, Enterprise Beans, and Resource Adapter Components
|
|

|java.security.AllPermission
|
|

|java.security.SecurityPermission
|
|

|java.security.UnresolvedPermission
|
|

|java.awt.AWTPermission
|
|

|java.io.SerializablePermission
|
|

|java.lang.reflect.ReflectPermission
|
|

|java.lang.RuntimePermission
|<any except loadLibrary.* and
queuePrintJob> footnote:[It must be possible
to deploy an application module such that no instances of
java.lang.RuntimePermission are granted to the components in the
application module except those with a target of loadlibrary.* for any
specific library or a target of queuePrintJob. Ideally a container would
be capable of restricting those as well, but that is not a requirement.]
|

|java.net.NetPermission
|
|

|java.sql.SQLPermission
|
|

|java.util.PropertyPermission
|<any>
|write footnote:[It must be possible to deploy an application module such that no
instances of java.util.PropertyPermission are granted that allow writing any
property.]

|java.util.logging.LoggingPermission
|
|

|javax.net.ssl.SSLPermission
|
|

|java.security.auth.AuthPermission
|
|

|java.security.auth.PrivateCredentialPermission
|
|

|java.security.auth.kerberos.DelegationPermission
|
|

|java.security.auth.kerberos.ServicePermission
|
|

|javax.sound.sampled.AudioPermission
|
|
|===

[[a2496]]
===== Declaring Permissions Required by Application Components

By declaring the permissions required by an
application as described in this section, an application component
provider is ensured, through the successful deployment of his or her
application, that the Jakarta EE Product has granted at least the declared
permissions to the classes and libraries packaged in the application
module.

Since the specific set of permissions granted
to a successfully deployed application is a function of the security
policy for the installation and the permissions declared within the
_permissions.xml_ files, the application component provider is ensured
that the effective permission set consists of at least those permissions
that are declared within the application.

Permission declarations must be stored in
_META-INF/permissions.xml_ file within an enterprise beans, web, application client,
or resource adapter archive in order for them to be located and
subsequently processed by the deployment machinery of the Jakarta EE
Product. The Jakarta EE Product is not required to support
_permissions.xml_ files that specify permission classes that are
packaged in the application.

The permissions for a packaged library are
the same as the permissions for the module. Thus, if a library is
packaged in a _.war_ file, it gets the permissions of the _.war_ file.

For applications packaged in an _.ear_ file,
the declaration of permissions must be at _.ear_ file level. This
permission set is applied to all modules and libraries packaged within
the _.ear_ file or within its contained modules. Any _permissions.xml_
files within such packaged modules are ignored, regardless of whether a
_permissions.xml_ file has been supplied for the _.ear_ file itself.

The fact that these permission declarations
are being made from within the context of a particular application
implies the codeBase(s) to which the grant should be made. This
simplifies the syntax that is needed to just the Permission class name
and two String arguments. This aligns the declaration syntax with the
default policy language and the constructor signature for permissions
that is compliant with the default policy syntax.

----
permission <class> [<name> [, <action list>]];
----


The following is an example of a permission
set declaration:

[source,xml]
----
...
<permissions>
  <permission>
    <class-name>java.io.FilePermission</class-name>
    <name>/tmp/abc</name>
    <actions>read,write</actions>
  </permission>
  <permission>
    <class-name>java.lang.RuntimePermission</class-name>
    <name>createClassLoader</name>
  </permission>
</permissions>
...
----


The Jakarta EE permissions XML Schema is located
at _http://xmlns.jcp.org/xml/ns/javaee/permissions_7.xsd_ .

==== Additional Requirements

[[a2523]]
===== Networking

The Java SE platform includes a pluggable
mechanism for supporting multiple URL protocols through the
_java.net.URLStreamHandler_ class and the
_java.net.URLStreamHandlerFactory_ interface.

The following URL protocols must be supported:

*  _file_ _:_ Only reading from a _file_ URL
need be supported. That is, the corresponding _URLConnection_ object’s
_getOutputStream_ method may fail with an _UnknownServiceException_ .
File access is restricted according to the permissions described above.
*  _http_ _:_ Version 1.1 of the HTTP protocol
must be supported. An _http_ URL must support both input and output.
*  _https_ : SSL version 3.0 and TLS version 1.2
must be supported by _https_ URL objects. Both input and output must be
supported.

The Java SE platform also includes a mechanism
for converting a URL’s byte stream to an appropriate object, using the
_java.net.ContentHandler_ class and _java.net.ContentHandlerFactory_
interface. A _ContentHandler_ object can convert a MIME byte stream to
an object. _ContentHandler_ objects are typically accessed indirectly
using the _getContent_ method of _URL_ and _URLConnection_ .

When accessing data of the following MIME types
using the _getContent_ method, objects of the corresponding Java type
listed in <<a2531, Java Type of Objects Returned When Using the getContent Method>> must be returned.

[[a2531]]
[cols=2, options=header]
.Java Type of Objects Returned When Using the getContent Method
|===
|MIME Type
|Java Type

|image/gif
|java.awt.Image

|image/jpeg
|java.awt.Image

|image/png
|java.awt.Image
|===

Many environments will use HTTP proxies rather
than connecting directly to HTTP servers. If HTTP proxies are being used
in the local environment, the HTTP support in the Java SE platform
should be configured to use the proxy appropriately. Application
components must not be required to configure proxy support in order to
use an _http_ URL.

Most enterprise environments will include a
firewall that limits access from the internal network (intranet) to the
public Internet, and vice versa. It is typical for access using the HTTP
protocol to pass through such firewalls, perhaps by using proxy servers.
It is not typical that general TCP/IP traffic, including RMI-JRMP, and
RMI-IIOP, can pass through firewalls.

These considerations have implications on the
use of various protocols to communicate between application components.
This specification requires that HTTP access through firewalls be
possible where local policy allows. Some Jakarta EE products may provide
support for tunneling other communication through firewalls, but this is
neither specified nor required. Application developers should consider
the impact of these issues in the design of applications, particularly
in view of cloud environments, where a cloud platform provider might
only allow HTTP-based access.

===== JDBC™ API

The JDBC API, which is part of the Java SE
platform, allows for access to a wide range of data storage systems. The
Java SE platform, however, does not require that a system meeting the
Java Compatible™ quality standards provide a database that is accessible
through the JDBC API.

To allow for the development of portable
applications, the Jakarta EE specification does require that such a
database be available and accessible from a Jakarta EE product through the
JDBC API. Such a database must be accessible from web components,
enterprise beans, and application clients, but need not be accessible
from applets. In addition, the driver for the database must meet the
JDBC Compatible requirements in the JDBC specification.

Jakarta EE applications should not attempt to
load JDBC drivers directly. Instead, they should use the technique
recommended in the JDBC specification and perform a JNDI lookup to
locate a _DataSource_ object. The JNDI name of the _DataSource_ object
should be chosen as described in
<<a1120, Resource Manager Connection Factory References>>. The Jakarta EE platform must be able to
supply a _DataSource_ that does not require the application to supply
any authentication information when obtaining a database connection. Of
course, applications may also supply a user name and password when
connecting to the database.

When a JDBC API connection is used in an
_enterprise bean_ , the transaction characteristics will typically be
controlled by the container. The component should not attempt to change
the transaction characteristics of the connection, commit the
transaction, roll back the transaction, or set autocommit mode. Attempts
to make changes that are incompatible with the current transaction
context may result in a _SQLException_ being thrown. The Jakarta Enterprise Beans
specification contains the precise rules for _enterprise beans._

Note that the same restrictions apply when a
component creates a transaction using the Jakarta Transactions _UserTransaction_
interface. The component should not attempt the operations listed above
on the JDBC _Connection_ object that would conflict with the transaction
context.

Drivers supporting the JDBC API in a Jakarta EE
environment must meet the JDBC API Compliance requirements as specified
in the JDBC specification.

The JDBC API includes APIs for connection
naming via JNDI, connection pooling, and distributed transaction
support. The connection pooling and distributed transaction features are
intended for use by JDBC drivers to coordinate with an application
server. Jakarta EE products are not required to support the application
server facilities described by these APIs, although they may prove
useful.

The Connector architecture defines an SPI
that essentially extends the functionality of the JDBC SPI with
additional security functionality, and a full packaging and deployment
functionality for resource adapters. A Jakarta EE product that supports the
Connector architecture must support deploying and using a JDBC driver
that has been written and packaged as a resource adapter using the
Connector architecture.

The JDBC 4.2 specification is available at
_https://jcp.org/en/jsr/detail?id=221_ .

[[a2553]]
===== Jakarta XML Web Services (JAX-WS™) Requirements (Optional)

The Jakarta XML Web Services specification provides support for
web services that use the Jakarta XML Binding API for binding XML data to Java objects.
The XML Web Services specification defines client APIs for accessing web services
as well as techniques for implementing web service endpoints. The Web
Services for Jakarta EE specification describes the deployment of
XML Web Services-based services and clients. The Enterprise Beans and Servlet specifications
also describe aspects of such deployment. It must be possible to deploy
XML Web Services-based applications using any of these deployment models.

The Jakarta XML Web Services specification describes the
support for message handlers that can process message requests and
responses. In general, these message handlers execute in the same
container and with the same privileges and execution context as the
Web Services client or endpoint component with which they are associated.
These message handlers have access to the same JNDI _java:comp/env_
namespace as their associated component. Custom serializers and
deserializers, if supported, are treated in the same way as message
handlers.

The Jakarta XML Web Services specification is available at
_https://jakarta.ee/specifications/xml-web-services/_ .

===== RMI-JRMP

JRMP is the Java technology-specific Remote
Method Invocation (RMI) protocol. The Jakarta EE security restrictions
typically prevent all application component types except application
clients from creating and exporting an RMI object, but all Jakarta EE
application component types can be clients of RMI objects.

===== RMI-IIOP

The RMI-IIOP subsystem is composed of APIs that allow for the
use of RMI-style programming that is independent of the underlying
protocol.  Implementations of these APIs may support the Java SE native RMI
protocol (JRMP), the CORBA IIOP protocol, or any custom protocol that is
compatible with the RMI programming restrictions.

NOTE: The requirements in this section only apply to Jakarta EE products that
include an Enterprise Beans container with support for remote interfaces.

Jakarta EE applications use the RMI-IIOP APIs when accessing
remote Enterprise Beans components, as described in the Jakarta Enterprise
Beans 4.0 specification.  This allows Enterprise Beans and their clients to be
protocol independent and portable to Jakarta EE implementations that may use
CORBA/IIOP, RMI, or any other custom protocol.

Requirements for distributed interoperability over CORBA/IIOP have been removed in
Jakarta Enterprise Beans 4.0. Use of the narrow method of `javax.rmi.PortableRemoteObject`
and references to `org.omg.ORB` in the Platform are slated for removal in a future release.

Jakarta EE implementations may use CORBA/IIOP as their underlying protocol, however,
such support is implementation-specific and no longer a guarantee of the Jakarta
EE platform.

===== JNDI

A Jakarta EE product that supports the following
types of objects must be able to make them available in the
application’s JNDI namespace: _EJBHome_ objects, _EJBLocalHome_ objects,
Enterprise Beans business interface objects, Jakarta Transactions _UserTransaction_ objects, JDBC API
_DataSource_ objects, JMS _ConnectionFactory_ and _Destination_ objects,
JavaMail _Session_ objects, _URL_ objects, resource manager
_ConnectionFactory_ objects (as specified in the Connector
specification), _ORB_ objects, _EntityManagerFactory_ objects, and other
Java language objects as described in
<<a567, Resources, Naming, and Injection>>. The JNDI implementation in a Jakarta EE product must be
capable of supporting all of these uses in a single application
component using a single JNDI _InitialContext_ . Application components
will generally create a JNDI _InitialContext_ using the default
constructor with no arguments. The application component may then
perform lookups on that _InitialContext_ to find objects as specified
above.

The names used to perform lookups for Jakarta EE
objects are application dependent. The application component’s metadata
annotations and/or deployment descriptor are used to list the names and
types of objects expected. The Deployer configures the JNDI namespace to
make appropriate components available. The JNDI names used to lookup
such objects must be in the JNDI _java:_ namespace. See
<<a567, Resources, Naming, and Injection>> for details.

Particular names are defined by this
specification for the cases when the Jakarta EE product includes the
corresponding technology. For all application components that have
access to the Jakarta Transaction _UserTransaction_ interface, the appropriate
_UserTransaction_ object can be found using the name
_java:comp/UserTransaction_ . In all containers except the applet
container, application components may lookup a CORBA _ORB_ instance
using the name _java:comp/ORB_ . For all application components that
have access to the CDI _BeanManager_ interface, the appropriate
_BeanManager_ object can be found using the name _java:comp/BeanManager_
. For all application components that have access to the Validation
APIs, the appropriate _Validator_ and _ValidatorFactory_ objects can be
found using the names _java:comp/Validator_ and
_java:comp/ValidatorFactory_ respectively.

The name used to lookup a particular Jakarta EE
object may be different in different application components. In general,
JNDI names can not be meaningfully passed as arguments in remote calls
from one application component to another remote component (for example,
in a call to an _enterprise bean_ ).

The JNDI _java:_ namespace is commonly
implemented as symbolic links to other naming systems. Different
underlying naming services may be used to store different kinds of
objects, or even different instances of objects. It is up to a Jakarta EE
product to provide the necessary JNDI service providers for accessing
the various objects defined in this specification.

This specification requires that the Jakarta EE
platform provide the ability to perform lookup operations as described
above. Different JNDI service providers may provide different
capabilities, for instance, some service providers may provide only
read-only access to the data in the name service.

A Jakarta EE product may be required to provide
a COSNaming name service to meet the Jakarta Enterprise Beans interoperability
requirements.  In such a case, a COSNaming JNDI service provider must be available
through the web, Enterprise Beans, and application client containers.

A COSNaming JNDI service provider is a part
of the Java SE 8 SDK and JRE from Oracle, but is not a required
component of the Java SE specification. The COSNaming JNDI service
provider specification is available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/jndi-cos.html_
.

See
<<a567, Resources, Naming, and Injection>> for the complete naming requirements for the Jakarta EE
platform. The JNDI specification is available at
_http://docs.oracle.com/javase/8/docs/technotes/guides/jndi/index.html_
.

===== Context Class Loader

This specification requires that Jakarta EE
containers provide a per thread context class loader for the use of
system or library classes in dynamically loading classes provided by the
application. The Jakarta Enterprise Beans specification requires that all
Jakarta Enterprise Beans client containers provide a per thread context class
loader for dynamically loading system value classes. The per thread context
class loader is accessed using the _Thread_ method _getContextClassLoader_ .

The classes used by an application will
typically be loaded by a hierarchy of class loaders. There may be a top
level application class loader, an extension class loader, and so on,
down to a system class loader. The top level application class loader
delegates to the lower class loaders as needed. Classes loaded by lower
class loaders, such as portable Jakarta Enterprise Beans system value classes, need to be
able to discover the top level application class loader used to
dynamically load application classes.

This specification requires that containers
provide a per thread context class loader that can be used to load top
level application classes as described above. See
<<a2966, Dynamic Class Loading>>
for recommendations for libraries that dynamically load classes.

===== Jakarta Authentication Requirements

All enterprise beans containers and all web containers
must support the use of the Jakarta Authentication APIs as specified in the Connector
specification. All application client containers must support use of the
Jakarta Authentication APIs.

The Jakarta Authentication specification is
available at _https://jakarta.ee/specifications/authentication_ .


===== Logging API Requirements

The Logging API provides classes and
interfaces in the _java.util.logging_ package that are the Java™
platform’s core logging facilities. This specification does not require
any additional support for logging. A Jakarta EE application typically will
not have the _LoggingPermission_ necessary to control the logging
configuration, but may use the logging API to produce log records. A
future version of this specification may require that the Jakarta EE
containers use the logging API to log certain events.

===== Preferences API Requirements

The Preferences API in the _java.util.prefs_
package allows applications to store and retrieve user and system
preference and configuration data. A Jakarta EE application typically will
not have the _RuntimePermission("preferences")_ necessary to use the
Preferences API. This specification does not define any relationship
between the principal used by a Jakarta EE application and the user
preferences tree defined by the Preferences API. A future version of
this specification may define the use of the Preferences API by Jakarta EE
applications.

=== Enterprise Beans 4.0 Requirements

This specification requires that a  Jakarta EE
product provide support for _enterprise beans_ as specified in the Jakarta Enterprise
Beans specification. The Jakarta Enterprise Beans specification is available at
_https://jakarta.ee/specifications/enterprise-beans_ .

A Jakarta EE product may support multiple object systems (for example,
RMI-IIOP, RMI-JRMP, gRPC, protobuf, Thrift).  There is no explicit
requirement that a Jakarta EE product support any specific protocol,
such as CORBA/IIOP, or provide distributed interoperability between
products.

In a Jakarta EE product that includes both an
enterprise beans container and a web container, both containers are required to
support access to local enterprise beans. No support is provided for
access to local enterprise beans from the application client container
or the applet container.

=== Servlet 5.0 Requirements

The Jakarta Servlet specification defines the
packaging and deployment of web applications, whether standalone or as
part of a Jakarta EE application. The Servlet specification also addresses
security, both standalone and within the Jakarta EE platform. These
optional components of the Servlet specification are requirements of the
Jakarta EE platform.

The Servlet specification includes additional
requirements for web containers that are part of a Jakarta EE product and a
Jakarta EE product must meet these requirements as well.

The Servlet specification defines
distributable web applications. To support Jakarta EE applications that are
distributable, this specification adds the following requirements.

Web containers must support Jakarta EE
distributable web applications placing objects of any of the following
types (when supported by the Jakarta EE product) into a
_jakarta.servlet.http.HttpSession_ object using the _setAttribute_ or
_putValue_ methods:

*  _java.io.Serializable_
*  _jakarta.ejb.EJBObject_
*  _jakarta.ejb.EJBHome_
*  _jakarta.ejb.EJBLocalObject_
*  _jakarta.ejb.EJBLocalHome_
*  _jakarta.transaction.UserTransaction_
* a _javax.naming.Context_ object for the
_java:comp/env_ context

a reference to an Enterprise Bean local or remote business interface or no-interface view

Web containers may support objects of other
types as well. Web containers must throw a
_java.lang.IllegalArgumentException_ if an object that is not one of the
above types, or another type supported by the container, is passed to
the _setAttribute_ or _putValue_ methods of an _HttpSession_ object
corresponding to a Jakarta EE distributable session. This exception
indicates to the programmer that the web container does not support
moving the object between VMs. A web container that supports multi-VM
operation must ensure that, when a session is moved from one VM to
another, all objects of supported types are accurately recreated on the
target VM.

The Servlet specification defines access to
local enterprise beans as an optional feature. This specification
requires that all Jakarta EE products that include both a web container and
an Enterprise Beans container provide support for access to local enterprise beans
from the web container.

The Jakarta Servlet specification is available at
_https://jakarta.ee/specifications/servlet_ .

=== Server Pages 3.0 Requirements

The Jakarta Server Pages specification depends on and builds
on the servlet framework. A Jakarta EE product must support the entire
Jakarta Server Pages specification.

The Jakarta Server Pages specification is available at
_https://jakarta.ee/specifications/pages_ .

=== Expression Language  (EL) 4.0 Requirements

The Jakarta Expression Language specification was
formerly a part of the Jakarta Server Pages specification. It was split off
into its own specification so that it could be used independently of
Jakarta Server Pages. A Jakarta EE product must support the Expression
Language.

The Jakarta Expression Language specification is
available at _https://jakarta.ee/specifications/expression-language_ .

=== Messaging 3.0 Requirements

A Jakarta Messaging provider must be
included in a Jakarta EE product that requires support for Jakarta Messaging.
The Jakarta Messaging implementation must provide support for both
Jakarta Messaging point-to-point and publish/subscribe messaging, and thus
must make those facilities available using the _ConnectionFactory_ and _Destination_ APIs.

The Jakarta Messaging specification defines several
interfaces intended for integration with an application server. A Jakarta
EE product need not provide objects that implement these interfaces, and
portable Jakarta EE applications must not use the following interfaces:

*  _jakarta.jms.ServerSession_
*  _jakarta.jms.ServerSessionPool_
*  _jakarta.jms.ConnectionConsumer_

all _jakarta.jms_ XA interfaces

The following methods may only be used by
application components executing in the application client container:

*  _jakarta.jms.MessageConsumer_ method
_getMessageListener_
*  _jakarta.jms.MessageConsumer_ method
_setMessageListener_
*  _jakarta.jms.JMSConsumer_ method
_getMessageListener_
*  _jakarta.jms.JMSConsumer_ method
_setMessageListener_
*  _jakarta.jms.Connection_ method
_setExceptionListener_
*  _jakarta.jms.Connection_ method _stop_
*  _jakarta.jms.Connection_ method
_setClientID_
*  _jakarta.jms.JMSContext_ method _stop_
*  _jakarta.jms.JMSContext_ method
_setClientID_
*  _jakarta.jms.JMSContext_ method
_setExceptionListener_
*  _jakarta.jms.JMSContext_ method
_createContext_
*  _jakarta.jms.Producer_ method _setAsync_
*  _jakarta.jms.MessageProducer_ method
_send(Message_ _message, CompletionListener_ _completionListener)_
*  _jakarta.jms.MessageProducer_ method
_send(Message_ _message,_ _int_ _deliveryMode,_ _int_ _priority,_ _long_
_timeToLive,_ _CompletionListener completionListener)_
*  _jakarta.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_
_CompletionListener_ _completionListener)_
*  _jakarta.jms.MessageProducer_ method
_send(Destination_ _destination, Message_ _message,_ _int_
_deliveryMode,_ _int_ _priority,_ _long_ _timeToLive,
CompletionListener_ _completionListener)_

The following methods may only be used by
application components executing in the application client container.
Note, however, that these methods provide an expert facility not used by
ordinary applications. See the JMS specification for further detail.

_jakarta.jms.Session_ method _setMessageListener_

*  _jakarta.jms.Session_ method
_getMessageListener_
*  _jakarta.jms.Session_ method _run_
*  _jakarta.jms.Connection_ method
_createConnectionConsumer_
*  _jakarta.jms.Connection_ method
_createSharedConnectionConsumer_
*  _jakarta.jms.Connection_ method
_createDurableConnectionConsumer_

_jakarta.jms.Connection_ method _createSharedDurableConnectionConsumer_

A Jakarta EE container may throw a
_JMSException_ (if allowed by the method) or a _JMSRuntimeException_ (if
throwing a _JMSException_ is not allowed by the method) if the
application component violates any of the above restrictions.

Application components in the web and enterprise bean
containers must not attempt to create more than one active (not closed)
_Session_ object per connection. An attempt to use the _Connection_
object’s _createSession_ method when an active _Session_ object exists
for that connection should be prohibited by the container. The container
should throw a _JMSException_ if the application component violates this
restriction. An attempt to use the _JMSContext_ object’s _createContext_
method should be prohibited by the container. The container should throw
a _JMSRuntimeException_ , since the first _JMSContext_ already contains
a connection and session and this method would create a second session
on the same connection. Application client containers must support the
creation of multiple sessions for each connection.

The Jakarta Messaging specification defines further
restrictions on the use of Jakarta Messaging in the Enterprise Beans and web containers. In
general, the behavior of a Jakarta Messaging provider should be the same in both the
enterprise beans container and the web container.

The Jakarta Messaging specification is available at
_https://jakarta.ee/specifications/messaging_ .

=== Transaction 2.0 Requirements

Jakarta Transaction defines the _UserTransaction_ interface
that is used by applications to start, and commit or abort transactions.
Application components get a _UserTransaction_ object through a JNDI
lookup using the name _java:comp/UserTransaction_ or by requesting
injection of a _UserTransaction_ object.

Jakarta Transaction also defines the
_TransactionSynchronizationRegistry_ interface that can be used by
system level components such as persistence managers to interact with
the transaction manager. These components get a
_TransactionSynchronizationRegistry_ object through a JNDI lookup using
the name _java:comp/TransactionSynchronizationRegistry_ or by requesting
injection of a _TransactionSynchronizationRegistry_ object.

A number of interfaces defined by Jakarta Transaction are used
by an application server to communicate with a transaction manager, and
for a transaction manager to interact with a resource manager. These
interfaces must be supported as described in the Connector
specification. In addition, support for other transaction facilities may
be provided transparently to the application by a Jakarta EE product.

The Jakarta Transaction specification is available at
_https://jakarta.ee/specifications/transactions_ .

=== Activation 2.0 Requirements

Jakarta Activation defines a set of standard services to: determine the MIME
type of an arbitrary piece of data; encapsulate access to it; discover the operations
available on it; and instantiate the appropriate bean to perform the operation(s).
A Jakarta EE product must support Activation.

The Jakarta Activation specification is available at
_https://jakarta.ee/specifications/activation_ .

=== Mail 2.0 Requirements

The Jakarta Mail API allows for access to email
messages contained in message stores, and for the creation and sending
of email messages using a message transport. Specific support is
included for Internet standard MIME messages. Access to message stores
and transports is through protocol providers supporting specific store
and transport protocols. The Jakarta Mail API specification does not require
any specific protocol providers, but the JavaMail reference
implementation includes an IMAP message store provider, a POP3 message
store provider, and an SMTP message transport provider.

Configuration of the Jakarta Mail API is
typically done by setting properties in a _Properties_ object that is
used to create a _jakarta.mail.Session_ object using a static factory
method. To allow the Jakarta EE platform to configure and manage JavaMail
API sessions, an application component that uses the JavaMail API should
request a _Session_ object using JNDI, and should list its need for a
_Session_ object in its deployment descriptor using a _resource-ref_
element, or by using a _Resource_ annotation. A Jakarta Mail API _Session_
object should be considered a resource factory, as described in
<<a1120, Resource Manager Connection Factory References>>. This specification requires that the
Jakarta EE platform support _jakarta.mail.Session_ objects as resource
factories, as described in that section.

The Jakarta EE platform requires that a message
transport be provided that is capable of handling addresses of type
_jakarta.mail.internet.InternetAddress_ and messages of type
_jakarta.mail.internet.MimeMessage_ . The default message transport must
be properly configured to send such messages using the _send_ method of
the _jakarta.mail.Transport_ class. Any authentication needed by the
default transport must be handled without need for the application to
provide a _jakarta.mail.Authenticator_ or to explicitly connect to the
transport and supply authentication information.

This specification does not require that a Jakarta
EE product support any message store protocols.

Note that the Jakarta Mail API creates threads to
deliver notifications of _Store_ , _Folder_ , and _Transport_ events.
The use of these notification facilities may be limited by the
restrictions on the use of threads in various containers. In Enterprise Beans
containers, for instance, it is typically not possible to create
threads.

The Jakarta Mail API uses the JavaBeans Activation
Framework API to support various MIME data types. The Jakarta Mail API must
include _jakarta.activation.DataContentHandlers_ for the following MIME
data types, corresponding to the Java programming language type
indicated in <<a2675, JavaMail API MIME Data Type to Java Type Mappings>> .

[[a2675]]
[cols=2, options=header]
.Jakarta Mail API MIME Data Type to Java Type Mappings
|===
|Mime Type
|Java Type

|text/plain
|java.lang.String

|text/html_
|java.lang.String

|text/xml
|java.lang.String

|multipart/*
|jakarta.mail.internet.MimeMultipart

|message/rfc822
|jakarta.mail.internet.MimeMessage
|===

The Jakarta Mail API specification is available
at _https://jakarta.ee/specifications/mail_ .

=== Connectors 2.0 Requirements

In full Jakarta EE products, all Jakarta Enterprise Beans containers
and all web containers must support the full set of Connector APIs. All
such containers must support Resource Adapters that use any of the
specified transaction capabilities. The Jakarta EE deployment tools must
support deployment of Resource Adapters, as defined in the Connector
specification, and must support the deployment of applications that use
Resource Adapters.

The Jakarta EE Connectors specification is available at
_https://jakarta.ee/specifications/connectors_ .

=== RESTful Web Services 3.0 Requirements

Jakarta RESTful Web Services defines APIs for the development of
Web services built according to the Representational State Transfer
(REST) architectural style.

In a full Jakarta EE product, all Jakarta EE web
containers are required to support applications that use Jakarta RESTful Web Services
technology.

The specification describes the deployment of
services as a servlet. It must be possible to deploy Jakarta RESTful Web Services-based
applications using this deployment model with the _servlet-class_
element of the web.xml descriptor naming the application-supplied
extension of the Jakarta RESTful Web Services _Application_ abstract class.

The specification defines a set of optional
container-managed facilities and resources that are intended to be
available in a Jakarta EE container — all such features and resources must
be made available.

The Jakarta RESTful Web Services specification is available at
_https://jakarta.ee/specifications/restful-ws_ .

=== WebSocket 2.0 (WebSocket) Requirements

The Jakarta WebSocket (WebSocket) is a
standard API for creating WebSocket applications. In a full Jakarta EE
product, all Jakarta EE web containers are required to support the
WebSocket API.

The Jakarta WebSocket specification can
be found at _https://jakarta.ee/specifications/websocket_ .

=== JSON Processing 2.0 (JSON-P) Requirements

JSON (JavaScript Object Notation) is a
lightweight data-interchange format used by many web services. The
Jakarta JSON Processing (JSON-P) provides a convenient way to process
(parse, generate, transform, and query) JSON text.

In a full Jakarta EE product, all Jakarta EE
application client containers, web containers, and enterprise beans containers are
required to support the JSON-P API.

The Jakarta JSON Processing
specification can be found at _https://jakarta.ee/specifications/jsonp_ .

[[a2713]]

=== JSON Binding 2.0 (JSON-B) Requirements

The Jakarta JSON Binding API for JSON Binding (JSON-B)
provides a convenient way to map between JSON text and Java objects.

In a full Jakarta EE product, all Jakarta EE
application client containers, web containers, and enterprise beans containers are
required to support the JSON-B API.

The Jakarta JSON Binding  specification
can be found at _https://jakarta.ee/specifications/jsonb_.

=== Concurrency 2.0 (Concurrency Utilities) Requirements

Jakarta Concurrency Utilities for Jakarta EE is a
standard API for providing asynchronous capabilities to Jakarta EE
application components through the following types of objects: managed
executor service, managed scheduled executor service, managed thread
factory, and context service. In a full Jakarta EE product, all web
containers and enterprise beans containers are required to support the Concurrency
Utilities API. The Jakarta EE Product Provider must provide preconfigured
default managed executor service, managed scheduled executor service,
managed thread factory, and context service objects for use by the
application in the containers in which the Concurrency Utilities API is
required to be supported.

The Jakarta Concurrency
specification can be found at _https://jakarta.ee/specifications/concurrency_ .

=== Batch 2.0 Specification Requirements

The Jakarta Batch provides a programming model for batch
applications and a runtime for scheduling and executing jobs.

In a full Jakarta EE product, all Jakarta EE web
containers and Jakarta Enterprise Beans containers are required to support the Batch API.

The Jakarta Batch specification can be found
at _https://jakarta.ee/specifications/batch_ .

=== Authorization 2.0 Requirements

The Jakarta Authorization specification defines a contract
between a Jakarta EE application server and an authorization policy
provider. In a full Jakarta EE product, all Jakarta EE web containers and
enterprise bean containers are required to support this contract.

The Jakarta Authorization specification can be found at
_https://jakarta.ee/specifications/authorization_ .

[[a2737]]
=== Authentication 2.0 Requirements

The Jakarta Authentication specification defines a service
provider interface (SPI) by which authentication providers implementing
message authentication mechanisms may be integrated in client or server
message processing containers or runtimes. Authentication providers
integrated through this interface operate on network messages provided
to them by their calling container. They transform outgoing messages
such that the source of the message may be authenticated by the
receiving container, and the recipient of the message may be
authenticated by the message sender. They authenticate incoming messages
and return to their calling container the identity established as a
result of the message authentication.

In a full Jakarta EE product, all Jakarta EE web
containers and enterprise bean containers are required to support the
baseline compatibility requirements as defined by the Jakarta Authentication
specification. In a full Jakarta EE product, all web containers must also
support the Servlet Container Profile as defined in the Jakarta Authentication
specification. In a Jakarta EE profile product that includes Servlet and
Jakarta Authentication, all web containers must also support the Servlet Container
Profile as defined in the Jakarta Authentication specification.
Support for the Jakarta Authentication SOAP Profile is not required.

The Jakarta Authentication specification can be found at
_https://jakarta.ee/specifications/authentication_ .

[[a2741]]
=== Security 2.0 Requirements

Jakarta Security leverages Jakarta Authentication ,
but provides an easier to use SPI for authentication of users of web
applications and defines identity store APIs for authentication and
authorization.

In a full Jakarta EE product, all Jakarta EE web
containers and enterprise bean containers are required to support the
requirements defined by the Jakarta Security specification.

The Jakarta Security Specification can be
found at _https://jakarta.ee/specifications/security_ .

=== Debugging Support for Other Languages Requirements 2.0

Jakarta Server Pages pages are usually translated into Java
language pages and then compiled to create class files. The Jakarta Debugging Support for Other Languages
specification describes information that can
be included in a class file to relate class file data to data in the
original source file. All Jakarta EE products are required to be able to
include such information in class files that are generated from
Jakarta Server Pages.

The Jakarta Debugging Support for Other Languages
specification can be found at _https://jakarta.ee/specifications/debugging_ .

=== Standard Tag Library for Jakarta Server Pages 2.0 Requirements

Jakarta Standard Tag Library specification defines a standard tag library that
makes it easier to develop Jakarta Server Pages Pages. All Jakarta EE products are required
to provide a Jakarta Standard Tag Library for use by all Jakarta Server Pages.

The Jakarta Standard Tag Library for Jakarta Server Pages
specification can be found at _https://jakarta.ee/specifications/tags_ .

=== Server Faces 3.0 Requirements

Jakarta Server Faces technology simplifies
building user interfaces for Jakarta applications. Developers of
various skill levels can quickly build web applications by: assembling
reusable UI components in a page; connecting these components to an
application data source; and wiring client-generated events to
server-side event handlers. In a full Jakarta EE product, all Jakarta EE web
containers are required to support applications that use the Jakarta Server
Faces technology.

The Jakarta Server Faces specification can be
found at _https://jakarta.ee/specifications/faces_ .

=== Annotations 2.0 Requirements

The Jakarta Annotations specification defines
Java language annotations that are used by several other specifications,
including this specification. The specifications that use these
annotations fully define the requirements for these annotations. All other
containers must provide definitions for all of these annotations, and
must support the semantics of these annotations as described in the
corresponding specifications and summarized in the following table.

[cols=4, options=header]
.Common Annotations Support by Container
|===
|Annotation
|App Client
|Web
|Enterprise Beans

|Resource
|Y
|Y
|Y

|Resources
|Y
|Y
|Y

|PostConstruct
|Y
|Y
|Y

|PreDestroy
|Y
|Y
|Y

|Generated
|N
|N
|N

|RunAs
|N
|Y
|Y

|DeclareRoles
|N
|Y
|Y

|RolesAllowed
|N
|Y
|Y

|PermitAll
|N
|Y
|Y

|DenyAll
|N
|Y
|Y

|ManagedBean
|Y
|Y
|Y

|DataSourceDefinition
|Y
|Y
|Y

|DataSourceDefinitions
|Y
|Y
|Y

|Priority
|Y
|Y
|Y
|===
The Jakarta Annotations specification can be found at
_https://jakarta.ee/specifications/annotations_ .

=== Persistence 3.0 Requirements

Jakarta Persistence is the standard API for the
management of persistence and object/relational mapping. The Jakarta
Persistence specification provides an object/relational mapping facility
for application developers using a Java domain model to manage a
relational database.

As mandated by the Jakarta Persistence
specification, in a Jakarta EE environment the classes of the persistence
unit should not be loaded by the application class loader or any of its
parent class loaders until after the entity manager factory for the
persistence unit has been created.

The Jakarta Persistence specification can be
found at _https://jakarta.ee/specifications/persistence_ .

=== Bean Validation 3.0 Requirements

The Bean Validation specification defines a
metadata model and API for JavaBean validation. The default metadata
source is annotations, with the ability to override and extend the
metadata through the use of XML validation descriptors.

The Jakarta EE platform requires that web
containers make an instance of _ValidatorFactory_ available to Jakarta Server Faces
implementations by storing it in a servlet context attribute named
_jakarta.faces.validator.beanValidator.ValidatorFactory._

The Jakarta EE platform also requires that an
instance of _ValidatorFactory_ be made available to Jakarta Persistence providers as a
property in the map that is passed as the second argument to the
_createContainerEntityManagerFactory(PersistenceUnitInfo, Map)_ method
of the _PersistenceProvider_ interface, under the name
_jakarta.persistence.validation.factory_ .

Additional requirements on Jakarta EE platform
containers are specified in the Bean Validation specification, which can
be found at _https://jakarta.ee/specifications/bean-validation_ .

=== Managed Beans 2.0 Requirements

The Managed Beans specification defines a
lightweight component model that supports the basic lifecycle model,
resource injection facility and interceptor service present in the Jakarta EE platform.

[NOTE]
====
Managed Beans is being deprecated in EE 10 for removal in a later version. The Managed Beans specification is a legacy notion that has been superceeded by the Jakarta Contexts and Dependency Injection specification and CDI beans should be used in place of Managed Beans.
====

The Managed Beans specification can be found
at _https://jakarta.ee/specifications/managedbeans_ .

=== Interceptors 2.1 Requirements

The Interceptors specification makes more
generally available the interceptor facility originally defined as part
of the Jakarta Enterprise Beans 3.0 specification.

The Interceptors specification can be found
at _https://jakarta.ee/specifications/interceptors_ .

=== Contexts and Dependency Injection (CDI) 4.0 Requirements

The Contexts and Dependency Injection (CDI)
specification defines a set of contextual services, provided by Jakarta EE
containers, aimed at simplifying the creation of applications that use
both web tier and business tier technologies.

The CDI specification can be found at
_https://jakarta.ee/specifications/cdi_ .

=== Dependency Injection for Java 2.0 Requirements

The Dependency Injection for Java (DI)
specification defines a standard set of annotations (and one interface)
for use on injectable classes.

In the Jakarta EE platform, support for
Dependency Injection is mediated by CDI. See
<<a2112, Support for Dependency Injection>> for more detail.

The DI specification can be found at
_https://jakarta.ee/specifications/dependency-injection_ .

=== Enterprise Web Services 2.0 Requirements (Optional)

The Enterprise Web Services specification defines the integration between the
various Web Service technologies in Jakarta EE, including XML Web Services and 
XML Web Service Metadata.
A Jakarta EE product may support Enterprise Web Services.

The Enterprise Web Services specification can be found
at _https://jakarta.ee/specifications/enterprise-ws_ .

=== XML Binding 4.0 Requirements (Optional)

The Jakarta XML Binding provides an API and tools that automate the mapping
between XML documents and Java objects.
A Jakarta EE product may support XML Binding.

The XML Binding specification can be found
at _https://jakarta.ee/specifications/xml-binding_ .

=== XML Web Services 4.0 Requirements (Optional)

Jakarta XML Web Services defines a means for implementing XML-Based Web Services
based on Jakarta SOAP with Attachments and Jakarta Web Services Metadata.
A Jakarta EE product may support XML Web Services.

The XML Web Services specification can be found
at _https://jakarta.ee/specifications/xml-web-services_ .
[NOTE]
====
Jakarta Web Services Metadata 3.0 was merged into Jakarta XML Web Services 4.0
====

=== SOAP with Attachments 3.0 Requirements (Optional)

Jakarta SOAP with Attachments defines an API enabling developers to produce and
consume messages conforming to the SOAP 1.1, SOAP 1.2, and SOAP Attachments Feature.
A Jakarta EE product may support SOAP with Attachments.

The SOAP with Attachments specification can be found
at _https://jakarta.ee/specifications/soap-attachments_ .

// generates a line between text and footnotes for pdf and html generation.
'''
